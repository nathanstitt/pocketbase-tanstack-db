# pbtsdb

> Type-safe PocketBase integration with TanStack Query and TanStack DB for React applications. Provides reactive collections with automatic real-time subscriptions, optimistic mutations, full TypeScript type safety, and minimal boilerplate.

This library connects PocketBase (backend-as-a-service) to TanStack's reactive database tools. Use it when building React applications that need real-time data synchronization with PocketBase while maintaining strict type safety.

## Core Pattern (React)

```typescript
// 1. Define schema with type and relations properties
export type Schema = {
    books: {
        type: Book;
        relations: {
            author?: Author;
        };
    };
    authors: {
        type: Author;
        relations: {};
    };
}

// 2. Create React integration with automatic type inference
const { Provider, useStore } = createReactCollections<Schema>(pb, queryClient)({
    books: defineCollection('books', {}),
    authors: defineCollection('authors', {}),
});

// 3. Wrap your app with Provider
<Provider>
    <App />
</Provider>

// 4. Use in components - fully typed automatically!
function BooksList() {
    const books = useStore('books');  // ✅ Typed automatically
    const { data } = useLiveQuery((q) => q.from({ books }));
    // Subscriptions start/stop automatically with component lifecycle
}

function BooksWithAuthors() {
    const [books, authors] = useStore('books', 'authors');  // ✅ Variadic access
    const { data } = useLiveQuery((q) =>
        q.from({ book: books })
            .join({ author: authors }, ({ book, author }) => eq(book.author, author.id))
    );
}
```

**useStore() API:**
- Single key: `useStore('books')` → returns typed collection
- Multiple keys: `useStore('books', 'authors')` → returns typed tuple
- NO manual type declarations needed - types inferred from `defineCollection`!

**Custom Collection Keys:**
```typescript
const { Provider, useStore } = createReactCollections<Schema>(pb, queryClient)({
    myBooks: defineCollection('books', {})  // Key 'myBooks', collection 'books'
});
```

## Key Concepts

- **createReactCollections**: One call creates Provider and typed useStore hook - no manual type declarations!
- **Collections are lazy**: No network activity until first query
- **Subscriptions are automatic**: Start when component mounts, stop 5s after unmount
- **Query-time expand**: Use `.expand()` method with `as const` arrays for type-safe field selection
- **Schema structure**: Use `type` and `relations` properties (lowercase, not `Row`/`Relations`)
- **Package name**: Import from `pbtsdb` (not `pocketbase-tanstack-db`)

## Non-React Usage

For non-React environments, use `CollectionFactory` directly:

```typescript
import { CollectionFactory } from 'pbtsdb';

const factory = new CollectionFactory<Schema>(pb, queryClient);
const booksCollection = factory.create('books');

// Manual data access (non-reactive)
const books = await booksCollection.getFullList();
```

## Testing

```bash
npm test  # Auto-resets DB, starts server, runs tests, stops server
```

Tests use real PocketBase instance (not mocked). Server infrastructure is fully automated.

## Documentation

- [AGENTS.md](AGENTS.md): Complete development guide with architecture, patterns, and testing
- [README.md](README.md): User-facing API reference with examples
- [test/schema.ts](test/schema.ts): Reference schema implementation

## Mutations

Collections support insert, update, and delete with automatic PocketBase sync:

```typescript
import { newRecordId, createReactCollections, defineCollection } from 'pbtsdb';

// Setup with custom mutation handlers (optional)
const { Provider, useStore } = createReactCollections<Schema>(pb, queryClient)({
    books: defineCollection('books', {
        onInsert: async ({ transaction }) => { /* custom logic */ },
        onUpdate: false, // Disable updates (throws error if called)
        onDelete: false, // Disable deletes
    })
});

// In component
function BooksList() {
    const books = useStore('books');

    // Insert with optimistic update (UI updates immediately)
    const tx = books.insert({
        id: newRecordId(), // Generate PocketBase-compatible ID
        title: 'New Book',
        // ... other fields
    });

    // Update with optimistic update
    books.update('record_id', (draft) => {
        draft.title = 'Updated Title';
    });

    // Update with config (non-optimistic - waits for server)
    books.update('record_id', { optimistic: false }, (draft) => {
        draft.title = 'Server-First Update';
    });

    // Delete with optimistic update
    books.delete('record_id');

    // Batch mutations - merges multiple updates to same record
    books.utils.writeBatch(() => {
        books.update('id1', (draft) => { draft.field1 = 'value1' });
        books.update('id1', (draft) => { draft.field2 = 'value2' }); // Merged!
        books.update('id2', (draft) => { draft.field = 'value' });
    });

    // Wait for persistence
    await tx.isPersisted.promise; // States: pending → persisting → completed
}
```

**Key Points:**
- Mutations are optimistic by default (UI updates immediately)
- Auto-syncs to PocketBase in background
- Batch mutations merge updates to same record
- Transaction states: pending → persisting → completed
- Use `newRecordId()` to generate PocketBase-compatible IDs

## Common Patterns

**Approach 1: Query-Time Expand (Recommended)**
```typescript
// Define which relations CAN be expanded at query time
const authorsCollection = factory.create('authors');
const booksCollection = factory.create('books', {
    expandable: {
        author: authorsCollection
    }
});

// Choose what to expand per-query
const booksWithAuthor = booksCollection.expand(['author'] as const);
const { data } = useLiveQuery((q) => q.from({ books: booksWithAuthor }));

// Expanded records automatically inserted into authorsCollection
// Different queries can expand different fields from same collection
```

**When to use Query-Time Expand:**
- Different queries need different expand combinations
- You want expanded records to populate their own collections automatically
- Building dashboards with varying detail levels
- Performance: Each expand combination cached separately

**Approach 2: TanStack Joins**
```typescript
const { Provider, useStore } = createReactCollections<Schema>(pb, queryClient)({
    jobs: defineCollection('jobs', {}),
    customers: defineCollection('customers', {}),
});

// In component
const [jobs, customers] = useStore('jobs', 'customers');
// Client-side joins with full type safety, supports inner/left/right/full joins
```

## Critical Rules

- NEVER use `any` types - defeats the purpose of this library
- ALWAYS use `as const` on `.expand()` field arrays for type inference
- Create ONE CollectionFactory instance per PocketBase connection
- Schema must match actual PocketBase collection structure
- Code should be self-documenting - avoid obvious comments

## Optional

### When NOT to Use

- Non-React environments (use PocketBase SDK directly)
- Simple CRUD without real-time (PocketBase SDK is simpler)
- Very large collections (>10k records - use pagination)
- Non-PocketBase backends (use TanStack Query directly)

### Package Details

- Requires React 18+, TypeScript 5.0+, PocketBase 0.21.0+
- Collections use TanStack Query for caching and TanStack DB for reactivity
- Real-time via PocketBase Server-Sent Events (SSE)
- Automatic reconnection with exponential backoff on subscription failures
