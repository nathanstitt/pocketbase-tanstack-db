import { renderHook, waitFor } from '@testing-library/react'
import { useLiveQuery } from '@tanstack/react-db'
import { and, eq, gt, gte, lt, lte, or } from '@tanstack/db'
import { afterAll, beforeAll, beforeEach, afterEach, describe, expect, it } from 'vitest'

import { CollectionFactory } from '../src/collection'
import { Schema } from './schema'
import { pb, createTestQueryClient, authenticateTestUser, clearAuth } from './helpers'
import type { QueryClient } from '@tanstack/react-query'

describe('Collection - Query Operators', () => {
    let queryClient: QueryClient

    beforeAll(async () => {
        await authenticateTestUser()
    })

    afterAll(() => {
        clearAuth()
    })

    beforeEach(() => {
        queryClient = createTestQueryClient()
    })

    afterEach(() => {
        queryClient.clear()
    })

    it('should filter jobs using eq operator', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        // First get all jobs to find a valid status
        const allJobs = await pb.collection('jobs').getList(1, 10)
        expect(allJobs.items.length).toBeGreaterThan(0)
        const testStatus = allJobs.items[0].status

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => eq(jobs.status, testStatus))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()
        expect(result.current.data.length).toBeGreaterThan(0)

        // All results should have the filtered status
        result.current.data.forEach(job => {
            expect(job.status).toBe(testStatus)
        })
    })

    it('should filter jobs using gt operator with dates', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        // Use a date in the past to ensure we get some results
        const pastDate = new Date('2020-01-01')

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => gt(jobs.created, pastDate.toISOString()))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()
        expect(result.current.data.length).toBeGreaterThan(0)

        // All results should have created date after pastDate
        result.current.data.forEach(job => {
            expect(new Date(job.created).getTime()).toBeGreaterThan(pastDate.getTime())
        })
    })

    it('should filter jobs using gte operator', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        // Get a job's created date to use as threshold
        const allJobs = await pb.collection('jobs').getList(1, 1, { sort: '-created' })
        expect(allJobs.items.length).toBeGreaterThan(0)
        const thresholdDate = allJobs.items[0].created

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => gte(jobs.created, thresholdDate))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()
        expect(result.current.data.length).toBeGreaterThan(0)

        // All results should have created date >= threshold
        result.current.data.forEach(job => {
            expect(new Date(job.created).getTime()).toBeGreaterThanOrEqual(new Date(thresholdDate).getTime())
        })
    })

    it('should filter jobs using lt operator', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        // Use a future date to ensure we get some results
        const futureDate = new Date('2030-01-01')

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => lt(jobs.created, futureDate.toISOString()))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()
        expect(result.current.data.length).toBeGreaterThan(0)

        // All results should have created date before futureDate
        result.current.data.forEach(job => {
            expect(new Date(job.created).getTime()).toBeLessThan(futureDate.getTime())
        })
    })

    it('should filter jobs using lte operator', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        const futureDate = new Date('2030-01-01')

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => lte(jobs.created, futureDate.toISOString()))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()
        expect(result.current.data.length).toBeGreaterThan(0)

        // All results should have created date <= futureDate
        result.current.data.forEach(job => {
            expect(new Date(job.created).getTime()).toBeLessThanOrEqual(futureDate.getTime())
        })
    })

    it('should filter jobs using and operator', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        // Get test data
        const allJobs = await pb.collection('jobs').getList(1, 10)
        expect(allJobs.items.length).toBeGreaterThan(0)
        const testStatus = allJobs.items[0].status
        const pastDate = new Date('2020-01-01')

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => and(
                        eq(jobs.status, testStatus),
                        gt(jobs.created, pastDate.toISOString())
                    ))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()

        // All results should match both conditions
        result.current.data.forEach(job => {
            expect(job.status).toBe(testStatus)
            expect(new Date(job.created).getTime()).toBeGreaterThan(pastDate.getTime())
        })
    })

    it('should filter jobs using or operator', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        // Get two different statuses
        const allJobs = await pb.collection('jobs').getList(1, 20)
        expect(allJobs.items.length).toBeGreaterThan(0)

        // Find two different status values
        const uniqueStatuses = [...new Set(allJobs.items.map(j => j.status))]
        const status1 = uniqueStatuses[0]
        const status2 = uniqueStatuses.length > 1 ? uniqueStatuses[1] : status1

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => or(
                        eq(jobs.status, status1),
                        eq(jobs.status, status2)
                    ))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()
        expect(result.current.data.length).toBeGreaterThan(0)

        // All results should match at least one condition
        result.current.data.forEach(job => {
            expect([status1, status2]).toContain(job.status)
        })
    })

    it('should sort jobs by created date descending', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .orderBy(({ jobs }) => jobs.created, 'desc')
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()
        expect(result.current.data.length).toBeGreaterThanOrEqual(1)

        // Verify descending order if we have multiple results
        if (result.current.data.length > 1) {
            const dates = result.current.data.map(j => new Date(j.created).getTime())
            for (let i = 1; i < dates.length; i++) {
                expect(dates[i]).toBeLessThanOrEqual(dates[i - 1])
            }
        }
    })

    it('should support complex nested queries with and/or', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)
        const jobsCollection = collections.create('jobs')

        const allJobs = await pb.collection('jobs').getList(1, 20)
        expect(allJobs.items.length).toBeGreaterThan(0)
        const testStatus = allJobs.items[0].status
        const pastDate = new Date('2020-01-01')
        const futureDate = new Date('2030-01-01')

        const { result } = renderHook(() =>
            useLiveQuery((q) =>
                q.from({ jobs: jobsCollection })
                    .where(({ jobs }) => and(
                        eq(jobs.status, testStatus),
                        or(
                            gt(jobs.created, pastDate.toISOString()),
                            lt(jobs.updated, futureDate.toISOString())
                        )
                    ))
            )
        )

        await waitFor(
            () => {
                expect(result.current.isLoading).toBe(false)
            },
            { timeout: 5000 }
        )

        expect(result.current.data).toBeDefined()

        // All results should match the complex condition
        result.current.data.forEach(job => {
            expect(job.status).toBe(testStatus)
            const meetsOrCondition =
                new Date(job.created).getTime() > pastDate.getTime() ||
                new Date(job.updated).getTime() < futureDate.getTime()
            expect(meetsOrCondition).toBe(true)
        })
    })

    it('should throw error for unsupported operators', async () => {
        const collections = new CollectionFactory<Schema>(pb, queryClient)

        // This test verifies that unsupported operators are rejected
        // by the query compilation, not by our converter
        // TanStack DB will throw a QueryCompilationError before reaching our code

        expect(() => {
            renderHook(() =>
                useLiveQuery((q) =>
                    q.from({ jobs: collections.create('jobs') })
                        // Testing unsupported structure
                        .where(() => ({ op: 'unsupported', field: ['name'], value: 'test' }) as any)
                )
            )
        }).toThrow()
    })
})
